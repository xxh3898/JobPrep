- 오늘 배운 것
	- jQuery 이벤트
	- 부트스트랩
	- hoisting
	- scope
	- closure
	- array_function
# jQuery 이벤트
```js
//$("선택자").이벤트(이벤트핸들러);
$(":submit").hover(function () {
	$(this).val("제출하기");
}, function () {
	$(this).val("완료");
});
```
### Effect 메서드
``` js
//보여주기
$("#show-btn").click(function () {
	$("#hide-show-img").show(500);
});

//숨기기
$("#hide-btn").click(function () {
	$("#hide-show-img").hide(1000);
});

//토글 
$("#toggle-btn").click(function () {
	$("#hide-show-img").toggle(1500);
});


//점점 선명하게 보임
$("#fedeIn-btn").click(function () {
	$("#fade-img").fadeIn(500);
});

//점점 흐려지면서 사라짐
$("#fedeOut-btn").click(function () {
	$("#fade-img").fadeOut(1000);
}); 

//토글
$("#fedeToggle-btn").click(function () {
	$("#fade-img").fadeToggle(1500);
});


//slideDown(), slideUp()
$(".qa-box > div").click(function () {
	console.log($(this).next()); //선택된요소에 뒤에있는 요소
	const $p = $(this).next();
	if ($p.css("display") === "none") {
		$(".qa-box > p").slideUp();
		$p.slideDown();
	} else {
		$p.slideUp();
	}
})
```
# 부트스트랩

	오픈소스 프론트엔드 프레임워크
	반응형 웹을 손쉽게 구현할 수 있음
	다양한 UI 컴포넌트 제공
# hoisiting
	js 엔진이 코드를 실행하기 전에 모든 변수선언과 함수선언을 메모리에 미리 등록해두는 동작
	그래서 선언이 코드 아래에 있어도 마치 코드의 최삳안으로 끌어올려진 것처럼 동작한다.
- TDZ(Temporal Dead Zone)
	let/const 변수가 선언되기 전까지 해당 변수를 기록해두는 공간으로 해당영역에 표시된 변수는 선언시점이 되지 않은 변수로 구분한다.
# Scope
	변수화 함수가 접근할 수 있는 유효범위
	즉, 이 변수/함수가 어디까지 보이고, 어디까지 쓸 수 있는지를 결정함
	
	전역스코프: 코드 어디서든 접근 가능한 영역(전역에서 선언된 변수/함수)
	함수스코프: 함수 내부에서만 접근 가능한 영역(var 키워드로 선언한 값)
	블록스코프: {}블록 내부에서만 접근이 가능한 영역(let, const 키워드로 선언한 값)
	렉시컬스코프: 선언된 위치 기준으로 스코프를 결정(js는 렉시컬스코프를 기반으로 함)
# Closure
	함수와 그 함수가 선언된 시점의 렉시컬 환경의 조합
	즉, 내부함수의 선언시점에 외부함수의 변수를 함께 저장해서 사용하는 것을 클로저라고 함
	콜백/이벤트 /헨들러/모듈패턴에서 핵심적인 역할을 함
	
# array_function
	자료형, 목적에따라 가장 간결하고 명확하게 구현하기 위한 다양한 반복문이 존재
	읽기/변환/필터링/검색 ... 목적에 맞는 반복문을 골라 사용해야 가독성이 높아짐
``` js
let members = [
	"최지원",
	"김지원",
	"이지원",
	"박지원",
	"정지원",
	"황지원",
]

//splice(인덱스, 몇개) -> 원본에서 특정 인덱스부터 n개를 잘라냄.
console.log(members.splice(1, 3));

//...배열 또는 ...객체 -> spread연산자
//배열이나 객체의 요소를 개별적으로 펼처서 복사하거나 전달할 때 사용.
let members2 = [
	...members,
	"신지원"
]

//값을 수정할 때
choi = {
	...choi,
	gender: "여"
};

//데이터를 추가할 때
choi = {
	...choi,
	address: "경기도 광명시"
}

//비구조할당
//배열이나 객체에서 값을 추출할 때 개별변수에 할당해서 추출하는 문법
members = [
	"최지원",
	"김지원",
	"이지원"
];

choi = {
	name: "jiwon",
	age: 24,
	gender: "남"
}; 

const { name, age } = choi;
console.log(name);
console.log(age);

//join(구분자) -> 배열을 문자열로 변경해줌.
console.log(members);
console.log(members.join());
console.log(members.join("/"));
  
//reverse() -> 배열을 지금상태에서 역순으로 정렬
console.log(members2);
members2.reverse();
console.log(members2);

//sort()
console.log(members2);
members2.sort(); //오름차순 정렬
console.log(members2);
members2.sort().reverse(); //내림차순

//js의 반복문
for (let i = 0; i < stdList.length; i++) {
	console.log(stdList[i]);
}

//for..of
//배열 값 중심으로 순회한다. 가장깔끔하며 인덱스가 필요없을 때 사용.

for (const std of stdList) {
	console.log(std);
}

//for..in
//인덱스 중심으로 순회한다.

for (const i in stdList) {
	console.log(i + "번째 : ", stdList[i]);
}

//객체에 사용시 key를 전부 열거할 수 있음.
const std = { name: "최지원", java: 75, db: 80, front: 90 };
for (const key in std) {
	console.log(key);
}

//----------배열의 고차함수---------------------------
// 읽기전용 + 새로운 배열/값을 반환 -> 불변경 유지를 위해
//배열.forEach(function(v: 순차적으로 요소하나, i: 인덱스번호, a: 전체배열){

stdList.forEach(function (v, i, a) {
	console.log(v, " ", i, " ", a);
});
```